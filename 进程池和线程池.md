通过动态创建子进程(或者子线程)来实现并发服务器有如下缺点：
- 动态创建进程或者线程地比较耗费时间的，这将导致较慢的客户响应。
- 动态创建的子进程或者子线程通常只用来为一个客户服务(除非我们做特殊的处理)，这将导致系统上产生大量的细微进程或者线程。进程或者线程间的切换将消耗大量CPU时间。
- 动态创建的子进程是当前进程的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性能

# 一、进程池和线程池概述
进程池和线程池相似，所以这里我们只以进程池为例进程简绍。

进程池是由服务器预先创建的一组子进程，这些子进程的数目在 3~10个之间(当然这只是典型情况)。httpd守护进程就是使用包含7个子进程的进程池来实现并发的。

线程池中的线程数量应该和CPU数量差不多。

进程池中的所有子进程都运行着相同的代码，并具有相同的属性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好了，所以每个子进程都相对“干净”，即它们没有打开不必要的文件描述符(从父进程继承而来)，也不会错误地使用大块的堆内存(从父进程复制得到)。

当有新的人任务到来时，主进程将通过某种方式选择进程池中的某一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在的子进程的代价显然要小得多。至于主进程选择哪个子进程来为之服务，则有两种方式：

    - 主进程使用某种算法来主动选择子进程。最简单、最常用的算法是随机算法和Round Robin算法，但更优秀、更智能的算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器的整体压力。
    - 主进程和所有子进程通过一个共享的工作队列来同步，子进程都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到工作队列中、这将唤醒正在等待任务的子进程，不过只有一子进程将获得新任务的“管理权”，它可以从工作队列中取出任务并执行之，而其他子进程将继续睡眠在工作队列上。
   
当选择好子进程后，主进程换需要使用某种机制通知来告诉目标子进程有新任务需要处理，并传递必要的数据。最简单的方法是，在父进程和子进程之间预先建立好一条管道，然后通过管道来实现所有的进程间通信(要预先定义好一套协议来规范管道的使用)。在父线程和子线程之间传递数据就要简单得多，因为我们可以把这些数据定义为全局的，那么它们本身就是被所有线程共享的。

进程池的一般模型如下:

![进程池的一般模型](https://wx3.sinaimg.cn/mw690/007ZL5VTly1g8tbkfj3j9j30fu04jwep.jpg)

# 二、处理多客户
在使用进程池处理多客户任务时，首先要考虑的是一个问题：**监听socket和连接socket是否都要由主进程来统一管理。**

    - 半同步/半反应堆模式是由主进程统一管理这两种socket的。
    - 半同步/半异步模式和领导者/追随者模式，则是由主进程管理所有监听socket，各个子进程分别管理属于自己的连接socket的。

前一种，主进程接受新的连接以得到连接socket(也就是accept()得到负责和客户交互的sock描述符)，然后它需要将该sock传递给子进程(对于线程池而言，线程将sock传递给子线程是很简单的，因为它们可以很容易地共享sock，但是对于进程池而言，我们必须使用管道来传递sock)。

后一种情况的灵活性更大一些，因为子进程可以自己调用accept来接受新的连接，这样父进程就无须向子进程传递sock，，而只需要简单通知一声：“我检测到新连接，你来接受它。”

---
   **常连接是什么？**
   ```http
   GET: http://www.baidu.com/index.html HTTP/1.0
   User-Agent: Wget/1.12 (linux=gun)
   Host: www.baidu.com
   Connection: close
   ```
   “Connection: close” 是我们只想wget命令时传入的，以告诉服务器处理完这个HTTP请求之后就关闭连接。在旧的HTTP协议中，Web客服端和Web服务器之间的一个TCP连接只能为一个HTTP请求服务。当处理完客户的一个HTTP请求之后，Web服务器就主动将TCP连接关闭了。此后同一个客户端再发送一个HTTP请求的话，必须与服务器建立一个新的TCP连接。也就是说，同一个客户的多个连续的HTTP请求不能共用同一个TCP连接，这称为**短连接。**
   
   长连接与之相反，是指多个请求可以使用同一个TCP连接。长连接在编程上稍微复杂一些，但性能上却又很大的提高：它极大的减少了网络上为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。

---

从上面了解到一个客户的多次请求可以复用一个TCP连接。那么，设计进程池时还需要考虑: 一个客户连接上的所有任务是否始终由一个子进程来处理。如果说客户任务是无序状态的，那么我们可以考虑用不同的子进程来为该客户的不同请求服务， 请看下图：

![进程池的一般模型](https://wx2.sinaimg.cn/mw690/007ZL5VTly1g903coge3rj30iy061aag.jpg)




   
   

























